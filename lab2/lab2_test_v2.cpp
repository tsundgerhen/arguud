#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

#define MAX_EXPANSIONS 125
#define MAX_TERMINALS 62
#define MAX_STRING_LENGTH 100
#define MAX_NON_TERMINALS 2

struct ProductionRule {
    char non_terminal;
    const char *expansions[MAX_EXPANSIONS]; 
};

struct CFG {
    struct ProductionRule *rules; 
    const char *terminals[MAX_TERMINALS];        
    char start_symbol;
};

std::vector<char> generate_terminals(){
    std::vector<char> terminals_generated;
    for(int i = 65; i < 91; i++){
        terminals_generated.push_back(char(i));
    }
    for(int i = 97; i < 123; i++){
        terminals_generated.push_back(char(i));
    }
    for(int i = 0; i < 10; i++){
        terminals_generated.push_back(std::to_string(i)[0]);
    }
    return terminals_generated;
}

std::vector<std::string> generate_rules(){
    std::vector<std::string> rules_generated, temp1;

    for(int i = 65; i < 91; i++){
        std::string rule;
        rule += char(i);
        rule += '@';
        rule += char(i);
        temp1.push_back(rule);
    }
    rules_generated.insert(rules_generated.end(), temp1.begin(), temp1.end());
    temp1.clear();

    for(int i = 97; i < 123; i++){
        std::string rule;
        rule += char(i);
        rule += '@';
        rule += char(i);
        temp1.push_back(rule);
    }
    rules_generated.insert(rules_generated.end(), temp1.begin(), temp1.end());
    temp1.clear();

    for(int i = 0; i < 10; i++){
        std::string rule;
        rule += std::to_string(i)[0];
        rule += '@';
        rule += std::to_string(i)[0];
        temp1.push_back(rule);
    }
    rules_generated.insert(rules_generated.end(), temp1.begin(), temp1.end());
    temp1.clear();

    return rules_generated;
}

void initialize_CFG(struct CFG *grammar) {
    grammar->rules = (struct ProductionRule*)malloc(MAX_NON_TERMINALS * sizeof(struct ProductionRule));
    
    std::vector<std::string> rules_generated = generate_rules();
    std::vector<char> terminals_generated = generate_terminals();
    
    grammar->rules[0].non_terminal = '@';
    for(size_t i = 0; i < rules_generated.size(); i++){
        grammar->rules[0].expansions[i] = rules_generated[i].c_str();
    }

    for(size_t i = rules_generated.size(); i < rules_generated.size() + terminals_generated.size(); i++){
        grammar->rules[0].expansions[i] = std::string(1, terminals_generated[i - rules_generated.size()]).c_str();
    }

    for(size_t i = 0; i < terminals_generated.size(); i++){
        grammar->terminals[i] = std::string(1, terminals_generated[i]).c_str();
    }
    grammar->rules[0].expansions[124] = ""; // Terminating the expansions array
    grammar->rules[1].non_terminal = '$';
    for(size_t i = 0; i < rules_generated.size(); i++){
        grammar->rules[1].expansions[i] = rules_generated[i].c_str();
    }

    for(size_t i = rules_generated.size(); i < rules_generated.size() + terminals_generated.size(); i++){
        grammar->rules[1].expansions[i] = std::string(1, terminals_generated[i - rules_generated.size()]).c_str();
    }
    grammar->rules[1].expansions[124] = ""; // Terminating the expansions array
    grammar->start_symbol = '@';
}

int isTerminal(char symbol) {
    std::vector<char> terminals_generated = generate_terminals();
    return (std::find(terminals_generated.begin(), terminals_generated.end(), symbol) != terminals_generated.end());
}   

int matchNonTerminal(struct CFG *grammar, std::string str, int *index, char non_terminal) {
    for (int i = 0; i < 2; i++) {
        if (grammar->rules[i].non_terminal == non_terminal) {
            for (int j = 0; j < MAX_EXPANSIONS; j++) {
                if (grammar->rules[i].expansions[j] != NULL) {
                    int tmpIndex = *index; 
                    if (str.find(grammar->rules[i].expansions[j], tmpIndex) == tmpIndex) {
                        tmpIndex += strlen(grammar->rules[i].expansions[j]);
                        *index = tmpIndex; 
                        return 1;
                    }
                } else {
                    break; 
                }
            }
        }
    }
    return 0;
}

int isPalindrome(struct CFG *grammar, std::string str) {
    int index = 0;
    return matchNonTerminal(grammar, str, &index, grammar->start_symbol) && (index == str.length());
}

int main() {
    std::string input;
    std::cout << "Enter a string: ";
    std::cin >> input;
    
    struct CFG grammar;
    initialize_CFG(&grammar);
    
    if (isPalindrome(&grammar, input)) {
        std::cout << input << " is generated by the CFG." << std::endl;
    } else {
        std::cout << input << " is not generated by the CFG." << std::endl;
    }
    free(grammar.rules);
    return 0;
}
